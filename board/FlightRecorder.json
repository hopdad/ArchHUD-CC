{
  "slots": {
    "0": {
      "name": "db",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "screen",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "-- ArchHUD Flight Recorder (Black Box) - Programming Board Script\n-- Records flight telemetry snapshots from the shared databank and displays\n-- historical data as scrolling line charts on a linked screen.\n--\n-- ═══════════════════════════════════════════════════════\n-- SETUP INSTRUCTIONS\n-- ═══════════════════════════════════════════════════════\n-- 1. Place a programming board, a screen, and link BOTH to the same databank\n--    used by your ArchHUD seat (the dbHud slot).\n-- 2. Right-click the programming board > Advanced > Edit Lua.\n-- 3. In the slot list (left side), rename the databank slot to \"db\"\n--    and the screen slot to \"screen\".\n-- 4. Select the filter: unit > onStart\n--    Paste this ENTIRE script into the code editor.\n-- 5. Add a NEW filter: unit > onTimer(timerId)\n--    Paste this single line:     onBoardTick(timerId)\n-- 6. Add a NEW filter: unit > onStop\n--    Paste this single line:     if screen then screen.setHTML(\"\") end\n-- 7. Apply changes and activate the programming board.\n-- ═══════════════════════════════════════════════════════\n--\n-- Slots (rename in the Lua editor slot list):\n--   db     = databank (same one linked to your seat/ECU as dbHud)\n--   screen = ScreenUnit\n--\n-- Databank keys:\n--   T_flight   (read)  - Real-time telemetry published by ArchHUD\n--   T_history  (write) - Rolling buffer of recorded snapshots\n\nlocal db = db ---@type databank\nlocal screen = screen ---@type ScreenUnit\nlocal unit = unit ---@type ProgrammingBoard\nlocal system = system\n\n-- json fallback for emulators (du-lua.dev) where the library slot\n-- doesn't inject the json global automatically.\nif not json then\n    json = {}\n    -- Minimal JSON decoder\n    function json.decode(s)\n        if not s or s == \"\" then return nil end\n        local i = 1\n        local V\n        local function w() while i <= #s and s:byte(i) <= 32 do i = i + 1 end end\n        local function S()\n            i = i + 1; local b = {}\n            while true do\n                local c = s:sub(i,i)\n                if c == '\"' then break\n                elseif c == '\\\\' then i=i+1; c=s:sub(i,i); if c=='n' then b[#b+1]='\\n' elseif c=='t' then b[#b+1]='\\t' else b[#b+1]=c end\n                else b[#b+1] = c end\n                i = i + 1\n            end\n            i = i + 1; return table.concat(b)\n        end\n        V = function()\n            w(); local c = s:sub(i,i)\n            if c == '\"' then return S()\n            elseif c == '{' then\n                i=i+1; w(); local t = {}\n                if s:sub(i,i) ~= '}' then\n                    local k = S(); w(); i=i+1; t[k] = V()\n                    while true do w(); if s:sub(i,i) ~= ',' then break end; i=i+1; k=S(); w(); i=i+1; t[k]=V() end\n                end; w(); i=i+1; return t\n            elseif c == '[' then\n                i=i+1; w(); local t = {}\n                if s:sub(i,i) ~= ']' then\n                    t[1]=V(); local n=1\n                    while true do w(); if s:sub(i,i) ~= ',' then break end; i=i+1; n=n+1; t[n]=V() end\n                end; w(); i=i+1; return t\n            elseif c == 't' then i=i+4; return true\n            elseif c == 'f' then i=i+5; return false\n            elseif c == 'n' then i=i+4; return nil\n            else local j2=i; if c=='-' then i=i+1 end; while i<=#s and s:sub(i,i):match('[%deE%.%+%-]') do i=i+1 end; return tonumber(s:sub(j2,i-1))\n            end\n        end\n        local ok, r = pcall(V); return ok and r or nil\n    end\n    -- Minimal JSON encoder\n    function json.encode(val)\n        local buf = {}\n        local function enc(v)\n            local tp = type(v)\n            if v == nil then buf[#buf+1] = \"null\"\n            elseif tp == \"boolean\" then buf[#buf+1] = v and \"true\" or \"false\"\n            elseif tp == \"number\" then\n                if v ~= v then buf[#buf+1] = \"null\"\n                elseif v == 1/0 then buf[#buf+1] = \"1e999\"\n                elseif v == -1/0 then buf[#buf+1] = \"-1e999\"\n                else buf[#buf+1] = string.format(\"%.14g\", v) end\n            elseif tp == \"string\" then\n                buf[#buf+1] = '\"'; buf[#buf+1] = v:gsub('[\\\\\"\\n\\t\\r]', {['\\\\']='\\\\\\\\',  ['\"']='\\\\\"', ['\\n']='\\\\n', ['\\t']='\\\\t', ['\\r']='\\\\r'}); buf[#buf+1] = '\"'\n            elseif tp == \"table\" then\n                -- Detect array vs object: sequential integer keys from 1..#v\n                local n = #v\n                local isArr = n > 0\n                if isArr then for k in pairs(v) do if type(k) ~= \"number\" or k < 1 or k > n or k ~= math.floor(k) then isArr = false; break end end end\n                if isArr then\n                    buf[#buf+1] = '['\n                    for i = 1, n do if i > 1 then buf[#buf+1] = ',' end; enc(v[i]) end\n                    buf[#buf+1] = ']'\n                else\n                    buf[#buf+1] = '{'\n                    local first = true\n                    for k2, v2 in pairs(v) do\n                        if type(k2) == \"string\" then\n                            if not first then buf[#buf+1] = ',' end; first = false\n                            enc(k2); buf[#buf+1] = ':'; enc(v2)\n                        end\n                    end\n                    buf[#buf+1] = '}'\n                end\n            end\n        end\n        enc(val)\n        return table.concat(buf)\n    end\nend\nlocal jdecode = json.decode\nlocal jencode = json.encode\nlocal mfloor = math.floor\nlocal stringf = string.format\n\n-- ════════════════════════════════════════════\n-- Constants\n-- ════════════════════════════════════════════\n\nlocal MAX_HISTORY = 180         -- Max snapshots (180 x 10s = 30 minutes)\nlocal RECORD_INTERVAL = 10     -- Seconds between snapshots / timer ticks\n\n-- Screen dimensions (DU HTML screen mode)\nlocal SW, SH = 1920, 1080\n\n-- ════════════════════════════════════════════\n-- Theme Colors\n-- ════════════════════════════════════════════\n\nlocal function rgb(r, g, b) return stringf(\"rgb(%d,%d,%d)\", r, g, b) end\nlocal function rgba(r, g, b, a) return stringf(\"rgba(%d,%d,%d,%.2f)\", r, g, b, a) end\n\nlocal accentColor = rgb(130, 224, 255)    -- Accent / speed line\nlocal dimColor    = rgb(90, 155, 180)     -- Dim labels\nlocal greenColor  = rgb(60, 255, 120)     -- Altitude line / live indicator\nlocal orangeColor = rgb(255, 165, 0)      -- V-speed line / stale warning\nlocal dangerColor = rgb(255, 60, 60)      -- Recording dot / old data\nlocal bgColor     = rgb(12, 16, 22)       -- Background\nlocal panelColor  = rgba(20, 30, 40, 0.85)\nlocal borderColor = rgba(130, 224, 255, 0.3)\nlocal gridColor   = rgba(130, 224, 255, 0.12)\n\n-- ════════════════════════════════════════════\n-- State\n-- ════════════════════════════════════════════\n\nlocal history = {}   -- Rolling buffer: each entry is {t=time, s=speed_mps, a=alt_m, v=vspd_mps}\n\n-- ════════════════════════════════════════════\n-- Data Persistence\n-- ════════════════════════════════════════════\n\n--- Load existing history from the databank (persists across restarts)\nlocal function loadHistory()\n    if db.hasKey(\"T_history\") then\n        local ok, data = pcall(jdecode, db.getStringValue(\"T_history\"))\n        if ok and type(data) == \"table\" then\n            history = data\n            system.print(stringf(\"Flight Recorder: Loaded %d snapshots from databank.\", #history))\n        end\n    end\nend\n\n--- Save the history buffer to the databank\nlocal function saveHistory()\n    db.setStringValue(\"T_history\", jencode(history))\nend\n\n-- ════════════════════════════════════════════\n-- Recording\n-- ════════════════════════════════════════════\n\n--- Read T_flight from the databank, append a snapshot if the data is new,\n--- trim the buffer to MAX_HISTORY, and persist.\n--- @return table|nil  The current flight data, or nil if unavailable\nlocal function recordSnapshot()\n    if not db.hasKey(\"T_flight\") then return nil end\n\n    local ok, flight = pcall(jdecode, db.getStringValue(\"T_flight\"))\n    if not ok or not flight or not flight.time then return nil end\n\n    -- Only record if this is genuinely new data\n    local n = #history\n    if n > 0 and history[n].t >= flight.time then\n        return flight   -- Same or older timestamp; skip recording\n    end\n\n    -- Append compact snapshot\n    history[n + 1] = {\n        t = flight.time,\n        s = flight.spd,\n        a = flight.alt,\n        v = flight.vspd,\n    }\n\n    -- Trim oldest entries if over capacity\n    while #history > MAX_HISTORY do\n        table.remove(history, 1)\n    end\n\n    -- Persist to databank\n    saveHistory()\n\n    return flight\nend\n\n-- ════════════════════════════════════════════\n-- Formatting Helpers\n-- ════════════════════════════════════════════\n\n--- Format speed value for Y-axis grid labels (km/h)\nlocal function fmtSpeedLabel(kmh)\n    if kmh > 10000 then\n        return stringf(\"%.1fk\", kmh / 1000)\n    else\n        return stringf(\"%.0f\", kmh)\n    end\nend\n\n--- Format speed for the current-value display\nlocal function fmtSpeedCurrent(kmh)\n    return stringf(\"%.0f km/h\", kmh)\nend\n\n--- Format altitude for Y-axis grid labels\nlocal function fmtAltLabel(meters)\n    if meters > 100000 then\n        return stringf(\"%.1f su\", meters / 200000)\n    elseif meters > 10000 then\n        return stringf(\"%.1f km\", meters / 1000)\n    elseif meters > 1000 then\n        return stringf(\"%.2f km\", meters / 1000)\n    else\n        return stringf(\"%.0f m\", meters)\n    end\nend\n\n--- Format altitude for current-value display\nlocal function fmtAltCurrent(meters)\n    if meters > 100000 then\n        return stringf(\"%.2f su\", meters / 200000)\n    elseif meters > 1000 then\n        return stringf(\"%.1f km\", meters / 1000)\n    else\n        return stringf(\"%.0f m\", meters)\n    end\nend\n\n--- Format vertical speed for Y-axis grid labels\nlocal function fmtVspdLabel(mps)\n    return stringf(\"%.1f\", mps)\nend\n\n--- Format vertical speed for current-value display\nlocal function fmtVspdCurrent(mps)\n    local sign = mps >= 0 and \"+\" or \"\"\n    return stringf(\"%s%.1f m/s\", sign, mps)\nend\n\n-- ════════════════════════════════════════════\n-- Chart Rendering\n-- ════════════════════════════════════════════\n\n--- Draw a single line chart within a panel region of the SVG.\n---\n--- @param svg       table    SVG string-builder table\n--- @param panelY    number   Top Y coordinate of the chart panel\n--- @param panelH    number   Height of the chart panel\n--- @param times     table    Array of timestamp values (arkTime)\n--- @param values    table    Array of data values for this metric\n--- @param n         number   Number of data points\n--- @param lineColor string   SVG color string for the data line\n--- @param chartLabel string  Title text displayed in the panel header\n--- @param fmtLabel  function Formatter for Y-axis grid labels\n--- @param fmtCurrent function Formatter for the large current-value display\n--- @param showZero  boolean  If true, ensure zero is in range and draw a dashed zero-line\nlocal function drawChart(svg, panelY, panelH, times, values, n,\n                         lineColor, chartLabel, fmtLabel, fmtCurrent, showZero)\n    -- Panel geometry\n    local panelX, panelW = 15, 1610\n    local plotX   = 105             -- Left edge of plot area (room for Y-axis labels)\n    local plotX2  = 1600            -- Right edge of plot area\n    local plotW   = plotX2 - plotX  -- 1495\n    local plotY   = panelY + 34    -- Top of plot area (below title)\n    local plotH   = panelH - 44    -- Height of plot area\n    local infoX   = 1660           -- X position for current-value readout\n\n    -- Panel background\n    svg[#svg+1] = stringf(\n        '<rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" fill=\"%s\" stroke=\"%s\" rx=\"6\"/>',\n        panelX, panelY, panelW, panelH, panelColor, borderColor)\n\n    -- Chart title\n    svg[#svg+1] = stringf(\n        '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"15\" font-family=\"monospace\" font-weight=\"bold\">%s</text>',\n        panelX + 15, panelY + 24, accentColor, chartLabel)\n\n    -- Empty state\n    if n == 0 then\n        svg[#svg+1] = stringf(\n            '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"16\" font-family=\"monospace\" text-anchor=\"middle\">NO RECORDED DATA</text>',\n            panelX + panelW / 2, panelY + panelH / 2, dimColor)\n        return\n    end\n\n    -- ── Compute value range ──────────────────\n\n    local vmin, vmax = values[1], values[1]\n    for i = 2, n do\n        if values[i] < vmin then vmin = values[i] end\n        if values[i] > vmax then vmax = values[i] end\n    end\n\n    -- For charts with a zero-line, ensure zero is always visible\n    if showZero then\n        if vmin > 0 then vmin = 0 end\n        if vmax < 0 then vmax = 0 end\n    end\n\n    -- Pad the range by 8% each side so lines don't sit on the edge\n    local range = vmax - vmin\n    if range < 0.1 then\n        -- Flat data: expand symmetrically\n        local center = (vmin + vmax) / 2\n        vmin = center - 1\n        vmax = center + 1\n        range = 2\n    else\n        vmin = vmin - range * 0.08\n        vmax = vmax + range * 0.08\n        range = vmax - vmin\n    end\n\n    -- ── Horizontal grid lines (6 lines, 5 intervals) ──\n\n    local numGrid = 5\n    for i = 0, numGrid do\n        local frac = i / numGrid\n        local gy = plotY + plotH - frac * plotH\n        local gv = vmin + frac * range\n\n        -- Grid line\n        svg[#svg+1] = stringf(\n            '<line x1=\"%d\" y1=\"%.1f\" x2=\"%d\" y2=\"%.1f\" stroke=\"%s\" stroke-width=\"0.5\"/>',\n            plotX, gy, plotX2, gy, gridColor)\n\n        -- Y-axis label\n        svg[#svg+1] = stringf(\n            '<text x=\"%d\" y=\"%.1f\" fill=\"%s\" font-size=\"11\" font-family=\"monospace\" text-anchor=\"end\">%s</text>',\n            plotX - 8, gy + 4, dimColor, fmtLabel(gv))\n    end\n\n    -- ── Zero reference line (dashed) ──\n\n    if showZero and vmin < 0 and vmax > 0 then\n        local zeroY = plotY + plotH - ((0 - vmin) / range) * plotH\n        svg[#svg+1] = stringf(\n            '<line x1=\"%d\" y1=\"%.1f\" x2=\"%d\" y2=\"%.1f\" stroke=\"%s\" stroke-width=\"1\" stroke-dasharray=\"6,4\"/>',\n            plotX, zeroY, plotX2, zeroY, rgba(255, 255, 255, 0.3))\n    end\n\n    -- ── Data polyline ──\n\n    local tStart = times[1]\n    local tEnd   = times[n]\n    local tRange = tEnd - tStart\n    if tRange < 1 then tRange = 1 end\n\n    local points = {}\n    for i = 1, n do\n        local xFrac = (times[i] - tStart) / tRange\n        local yFrac = (values[i] - vmin) / range\n        local px = plotX + xFrac * plotW\n        local py = plotY + plotH - yFrac * plotH\n        points[i] = stringf(\"%.1f,%.1f\", px, py)\n    end\n\n    svg[#svg+1] = stringf(\n        '<polyline points=\"%s\" fill=\"none\" stroke=\"%s\" stroke-width=\"2\" stroke-linejoin=\"round\" stroke-linecap=\"round\"/>',\n        table.concat(points, \" \"), lineColor)\n\n    -- Endpoint dot at the most recent data point\n    local endX = plotX + ((times[n] - tStart) / tRange) * plotW\n    local endY = plotY + plotH - ((values[n] - vmin) / range) * plotH\n    svg[#svg+1] = stringf(\n        '<circle cx=\"%.1f\" cy=\"%.1f\" r=\"4\" fill=\"%s\"/>',\n        endX, endY, lineColor)\n\n    -- ── Current value readout (right side) ──\n\n    svg[#svg+1] = stringf(\n        '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"12\" font-family=\"monospace\">CURRENT</text>',\n        infoX, panelY + 22, dimColor)\n    svg[#svg+1] = stringf(\n        '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"26\" font-family=\"monospace\" font-weight=\"bold\">%s</text>',\n        infoX, panelY + 52, lineColor, fmtCurrent(values[n]))\n\n    -- Min / Max summary\n    local actualMin, actualMax = values[1], values[1]\n    for i = 2, n do\n        if values[i] < actualMin then actualMin = values[i] end\n        if values[i] > actualMax then actualMax = values[i] end\n    end\n    svg[#svg+1] = stringf(\n        '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"11\" font-family=\"monospace\">MAX %s</text>',\n        infoX, panelY + 74, dimColor, fmtLabel(actualMax))\n    svg[#svg+1] = stringf(\n        '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"11\" font-family=\"monospace\">MIN %s</text>',\n        infoX, panelY + 90, dimColor, fmtLabel(actualMin))\nend\n\n-- ════════════════════════════════════════════\n-- Main Render Function\n-- ════════════════════════════════════════════\n\n--- Build and return the full SVG string for the flight recorder display.\nlocal function render()\n    local n   = #history\n    local now = system.getArkTime()\n\n    local svg = {}\n    svg[#svg+1] = stringf('<svg viewBox=\"0 0 %d %d\" xmlns=\"http://www.w3.org/2000/svg\">', SW, SH)\n\n    -- Background\n    svg[#svg+1] = stringf('<rect width=\"%d\" height=\"%d\" fill=\"%s\"/>', SW, SH, bgColor)\n\n    -- ── Title Bar ──\n\n    svg[#svg+1] = stringf(\n        '<rect x=\"0\" y=\"0\" width=\"%d\" height=\"50\" fill=\"%s\"/>',\n        SW, rgba(20, 30, 40, 0.95))\n    svg[#svg+1] = stringf(\n        '<text x=\"20\" y=\"34\" fill=\"%s\" font-size=\"22\" font-family=\"monospace\" font-weight=\"bold\">ARCHHUD FLIGHT RECORDER</text>',\n        accentColor)\n\n    -- ── Recording Status Indicator ──\n\n    local hasData = n > 0\n    local isRecording = hasData and (now - history[n].t) < 30\n\n    if isRecording then\n        svg[#svg+1] = stringf(\n            '<circle cx=\"%d\" cy=\"28\" r=\"6\" fill=\"%s\"/>' ..\n            '<text x=\"%d\" y=\"34\" fill=\"%s\" font-size=\"16\" font-family=\"monospace\" font-weight=\"bold\">REC</text>' ..\n            '<text x=\"%d\" y=\"34\" fill=\"%s\" font-size=\"14\" font-family=\"monospace\">%d samples</text>',\n            SW - 260, dangerColor,\n            SW - 248, dangerColor,\n            SW - 200, dimColor, n)\n    else\n        svg[#svg+1] = stringf(\n            '<circle cx=\"%d\" cy=\"28\" r=\"6\" fill=\"%s\"/>' ..\n            '<text x=\"%d\" y=\"34\" fill=\"%s\" font-size=\"16\" font-family=\"monospace\">NO DATA</text>',\n            SW - 260, rgba(80, 80, 80, 0.8),\n            SW - 248, dimColor)\n    end\n\n    -- ── Extract data arrays from history ──\n\n    local times, speeds, alts, vspeeds = {}, {}, {}, {}\n    for i = 1, n do\n        local h = history[i]\n        times[i]   = h.t\n        speeds[i]  = h.s * 3.6     -- Convert m/s to km/h for display\n        alts[i]    = h.a\n        vspeeds[i] = h.v\n    end\n\n    -- ── Chart Layout ──\n    -- Three stacked charts, each 290px tall, with the shared time axis below\n\n    local chartH  = 290\n    local chartY1 = 60    -- Speed chart (top)\n    local chartY2 = 360   -- Altitude chart (middle)\n    local chartY3 = 660   -- V-Speed chart (bottom)\n\n    drawChart(svg, chartY1, chartH, times, speeds, n,\n        accentColor, \"SPEED (km/h)\", fmtSpeedLabel, fmtSpeedCurrent, false)\n\n    drawChart(svg, chartY2, chartH, times, alts, n,\n        greenColor, \"ALTITUDE\", fmtAltLabel, fmtAltCurrent, false)\n\n    drawChart(svg, chartY3, chartH, times, vspeeds, n,\n        orangeColor, \"VERTICAL SPEED (m/s)\", fmtVspdLabel, fmtVspdCurrent, true)\n\n    -- ── Shared X-Axis (Time) ──\n\n    local axisY = 960\n    local plotX, plotX2 = 105, 1600\n    local plotW = plotX2 - plotX\n\n    if n > 1 then\n        local tStart = times[1]\n        local tEnd   = times[n]\n        local totalSec = tEnd - tStart\n\n        -- Choose tick interval based on data span\n        local tickInterval\n        if totalSec > 1500 then     tickInterval = 300    -- 5-minute ticks\n        elseif totalSec > 600 then  tickInterval = 120    -- 2-minute ticks\n        elseif totalSec > 300 then  tickInterval = 60     -- 1-minute ticks\n        else                        tickInterval = 30     -- 30-second ticks\n        end\n\n        -- Axis baseline\n        svg[#svg+1] = stringf(\n            '<line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"%s\" stroke-width=\"1\"/>',\n            plotX, axisY, plotX2, axisY, borderColor)\n\n        -- Tick marks and labels\n        local maxTicks = mfloor(totalSec / tickInterval)\n        for i = 0, maxTicks do\n            local secAgo = i * tickInterval\n            local t = tEnd - secAgo\n            if t >= tStart then\n                local x = plotX + ((t - tStart) / totalSec) * plotW\n\n                -- Tick mark\n                svg[#svg+1] = stringf(\n                    '<line x1=\"%.1f\" y1=\"%d\" x2=\"%.1f\" y2=\"%d\" stroke=\"%s\" stroke-width=\"1\"/>',\n                    x, axisY, x, axisY + 8, dimColor)\n\n                -- Time label\n                local label\n                if secAgo == 0 then\n                    label = \"now\"\n                elseif secAgo < 60 then\n                    label = stringf(\"%ds\", secAgo)\n                else\n                    label = stringf(\"%dm\", mfloor(secAgo / 60))\n                end\n                svg[#svg+1] = stringf(\n                    '<text x=\"%.1f\" y=\"%d\" fill=\"%s\" font-size=\"12\" font-family=\"monospace\" text-anchor=\"middle\">%s</text>',\n                    x, axisY + 22, dimColor, label)\n            end\n        end\n    end\n\n    -- ── Data Freshness Indicator (bottom-left) ──\n\n    if n > 0 then\n        local age = now - history[n].t\n        local freshColor, freshText\n        if age < 15 then\n            freshColor = greenColor\n            freshText = \"LIVE\"\n        elseif age < 30 then\n            freshColor = orangeColor\n            freshText = stringf(\"%.0fs AGO\", age)\n        else\n            freshColor = dangerColor\n            freshText = stringf(\"%.0fs AGO\", age)\n        end\n\n        svg[#svg+1] = stringf(\n            '<circle cx=\"30\" cy=\"%d\" r=\"5\" fill=\"%s\"/>' ..\n            '<text x=\"42\" y=\"%d\" fill=\"%s\" font-size=\"13\" font-family=\"monospace\">DATA: %s</text>',\n            SH - 20, freshColor, SH - 15, freshColor, freshText)\n\n        -- Recording duration (bottom-right)\n        local duration = now - history[1].t\n        local durText\n        if duration > 3600 then\n            durText = stringf(\"%.1fh recorded\", duration / 3600)\n        elseif duration > 60 then\n            durText = stringf(\"%dm recorded\", mfloor(duration / 60))\n        else\n            durText = stringf(\"%ds recorded\", mfloor(duration))\n        end\n        svg[#svg+1] = stringf(\n            '<text x=\"%d\" y=\"%d\" fill=\"%s\" font-size=\"13\" font-family=\"monospace\" text-anchor=\"end\">%s</text>',\n            SW - 20, SH - 15, dimColor, durText)\n    end\n\n    svg[#svg+1] = \"</svg>\"\n    return table.concat(svg)\nend\n\n-- ════════════════════════════════════════════\n-- Combined Record + Render\n-- ════════════════════════════════════════════\n\n--- Called every timer tick: records a snapshot then re-renders the display.\nfunction recordAndRender()\n    recordSnapshot()\n    screen.setHTML(render())\nend\n\n--- Check recorded history for anomalies and write alert if detected\nlocal function checkAlerts()\n    local n = #history\n    if n < 4 then return end -- Need at least 4 snapshots (40s of data)\n\n    local cur = history[n]\n    local prev = history[n - 3] -- 30 seconds ago\n    local alertMsg = nil\n\n    -- Alert: rapid altitude loss (>1000m in 30s while not near ground)\n    if prev.a and cur.a and prev.a > 500 then\n        local altDrop = prev.a - cur.a\n        if altDrop > 1000 then\n            alertMsg = stringf(\"ALERT: Rapid altitude loss! -%dm in 30s\", mfloor(altDrop))\n        end\n    end\n\n    -- Alert: sudden speed loss (>50% drop in 30s, from >100 m/s)\n    if prev.s and cur.s and prev.s > 100 then\n        local spdDrop = prev.s - cur.s\n        if spdDrop > prev.s * 0.5 then\n            alertMsg = stringf(\"ALERT: Sudden deceleration! %.0f -> %.0f m/s\", prev.s, cur.s)\n        end\n    end\n\n    if alertMsg then\n        db.setStringValue(\"A_recorder\", jencode({\n            msg = alertMsg,\n            t = system.getArkTime()\n        }))\n    end\nend\n\n-- ════════════════════════════════════════════\n-- Timer callback (global so unit > onTimer can call it)\n-- In unit > onTimer, paste:  onBoardTick(timerId)\n-- ════════════════════════════════════════════\nfunction onBoardTick(timerId)\n    if timerId == \"refresh\" then\n        if screen and db then\n            recordAndRender()\n            checkAlerts()\n        end\n    end\nend\n\n-- ════════════════════════════════════════════\n-- Auto-initialization (runs on unit > onStart)\n-- ════════════════════════════════════════════\nif not db then\n    system.print(\"ArchHUD Recorder: No databank linked. Rename the databank slot to 'db' and restart.\")\n    return\nend\nif not screen then\n    system.print(\"ArchHUD Recorder: No screen linked. Rename the screen slot to 'screen' and restart.\")\n    return\nend\nloadHistory()\nunit.setTimer(\"refresh\", RECORD_INTERVAL)\nsystem.print(\"ArchHUD Flight Recorder started.\")\nrecordAndRender()\n",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "onBoardTick(timerId)",
      "filter": {
        "args": [
          {
            "value": "refresh"
          }
        ],
        "signature": "onTimer(timerId)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "if screen then screen.setHTML(\"\") end",
      "filter": {
        "args": [],
        "signature": "onStop()",
        "slotKey": "-1"
      },
      "key": "2"
    }
  ],
  "methods": [],
  "events": []
}